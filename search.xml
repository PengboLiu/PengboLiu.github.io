<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[论文笔记] 抽取式自动文本摘要模型——SummaRuNNer]]></title>
    <url>%2F2018%2F11%2F13%2F%5B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%5D%20%E6%8A%BD%E5%8F%96%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94SummaRuNNer%2F</url>
    <content type="text"><![CDATA[论文概述本文发表在AAAI 2017上，作者是Ramesh Nallapati, Feifei Zhai和Bowen Zhou，论文链接：https://arxiv.org/abs/1611.04230 这篇文章提出了一个基于RNN的模型，来完成抽取式自动文本摘要任务。模型公式具有可解释性，并且可以利用已有的abstractive summary数据训练我们的extractive model。 SummaRuNNer模型作者把抽取式摘要（extractive summarization）问题转化为一个序列分类（sequence classification）问题：对文章的每句话都做一个二分类，被选中为摘要的一部分就标注为1，未被选中就标注为0。当然了，因为使用了RNN，每次做分类的时候，都会考虑之前句子的分类情况。 GRU本模型使用的是RNN的变体——GRU。$u$被称作update gate，$r$被称作reset gate，$W$和$b$是模型需要训练的参数，$h$是真实值隐状态（ real-valued hidden-state）。GRU的计算公式如下：\begin{aligned} \mathbf { u } _ { j } &amp; = \sigma \left( \mathbf { W } _ { u x } \mathbf { x } _ { j } + \mathbf { W } _ { u h } \mathbf { h } _ { j - 1 } + \mathbf { b } _ { u } \right) \\ \mathbf { r } _ { j } &amp; = \sigma \left( \mathbf { W } _ { r x } \mathbf { x } _ { j } + \mathbf { W } _ { r h } \mathbf { h } _ { j - 1 } + \mathbf { b } _ { r } \right) \\ \mathbf { h } _ { j } ^ { \prime } &amp; = \tanh \left( \mathbf { W } _ { h x } \mathbf { x } _ { j } + \mathbf { W } _ { h h } \left( \mathbf { r } _ { j } \odot \mathbf { h } _ { j - 1 } \right) + \mathbf { b } _ { h } \right) \\ \mathbf { h } _ { j } &amp; = \left( 1 - \mathbf { u } _ { j } \right) \odot \mathbf { h } _ { j } ^ { \prime } + \mathbf { u } _ { j } \odot \mathbf { h } _ { j - 1 } \end{aligned} 文本表示处理NLP问题，首先需要做的就是文本表示。研究目的是抽取一篇文章的摘要，而一篇文章是由若干句子构成，一句话又包含了若干单词。所以本文先后在单词级别和句子级别建模最后得到文本表示，细节如下： 首先对单词向量化（Word Embedding）。本文使用Google的Word2Vec工具训练得到词向量（100维）。 使用双向的RNN（也就是Bi-GRU）计算每个位置的隐状态表示（hidden state representations），输入是第一步得到的词向量。 使用另外一个双向RNN（同样是Bi-GRU），输入是上一步的隐状态表示做average pooling。 最后通过一个非线性转换得到整个文本的表示。$d$是文本表示，$W_d$是参数，$N_d$代表隐状态数量，$\left[ \mathbf { h } _ { j } ^ { f } , \mathbf { h } _ { j } ^ { b } \right]$是上一步双向RNN的隐状态输出。计算文本表示的公式如下：$$\mathbf { d } = \tanh \left( W _ { d } \frac { 1 } { N _ { d } } \sum _ { j = 1 } ^ { N ^ { d } } \left[ \mathbf { h } _ { j } ^ { f } , \mathbf { h } _ { j } ^ { b } \right] + \mathbf { b } \right)$$ 通过以上几个步骤我们得到了文本表示。 分类层然后，我们就可以预测每个句子是否被选中作为摘要的一部分。这其实是一个分类问题。我们遍历每个句子，使用二分类的方法判断这个句子需不需要加入摘要里面去，对应于一个logistic layer。计算公式如下： 解读一下公式中的字母： $W_c,W_s,W_r,W_{ap},W_{rp},b$ 均为模型可训练参数； $y_i$代表这句话是否被摘要选中（选中就是1）； $h_j$是句子级RNN输出的隐状态； $d$是经过非线性转换的文本表示； $s_j$是第$j$个位置的动态摘要表示，这里提出如下公式计算动态摘要表示：$$\mathbf { s } _ { j } = \sum _ { i = 1 } ^ { j - 1 } \mathbf { h } _ { i } P \left( y _ { i } = 1 | \mathbf { h } _ { i } , \mathbf { s } _ { i } , \mathbf { d } \right)$$ ${ p } _ { j } ^ { a }$是绝对位置向量（absolute positional embeddings），${ p } _ { j } ^ { r }$是相对位置向量（relative positional embeddings） 通过分类层的公式计算，我们可以预测每句话被选中到摘要的概率。到此为止，整个模型的架构已经全部搭建完成，如下图，就是SummaRuNNer的模型结构： 损失函数损失函数（loss function）如下：$l ( \mathbf { W } , \mathbf { b } ) = - \sum _ { d = 1 } ^ { N }\sum _ { j = 1 } ^ { N_d } ( y _ { j } ^ { d } \log P \left( y _ { j } ^ { d } = 1 | \mathbf { h } _ { j } ^ { d } , \mathbf { s } _ { j } ^ { d } , \mathbf { d } _ { d } \right) \\ +\left( 1 - y _ { j } ^ { d } \right) \log \left( 1 - P \left( y _ { j } ^ { d } = 1 | \mathbf { h } _ { j } ^ { d } , \mathbf { s } _ { j } ^ { d } , \mathbf { d } _ { d } \right) \right)$ 其实就是一个负对数似然（negative log-likelihood），我们的目标就是优化损失函数，使其最小。 Extractive Training但是目前很多文本摘要数据集的摘要部分都是人为概括出来的，所以不能直接用于SummaRuNNer这个模型的抽取式训练。论文中使用贪心算法来抽取文章的句子添加到训练时使用的参考文摘里。 Abstrctive Training在SummaRuNNer这个模型的基础上，作者在后面增加一个RNN Decoder，使得模型也可以被摘要是地训练。以上两种训练方法讲解的比较少，想要深入了解可以参考论文原文。之所以对两种训练方法讲解的较少，是因为本人发现github中关于本论文的代码实现使用的数据集在训练集验证集测试集中，已经直接标注了哪句话被摘要选中，所以我们在实际训练的时候可以当做一个单纯的分类问题来考虑。 实验与结果数据集 CNN/DailyMail语料： 196557 training documents, 12147 validation documents and 10396 test documents，平均而言，每个document有28个句子，每个summary中有3-4个句子； DUC2002语料：567个document； 模型设置 word embedding：使用Google的Word2Vec训练得到，100维 vocabulary size：150k 每篇文章的最大句子数：100 每句话的最多单词数：50 hidden state size：200 batch size：64 optimizer：adadelta 使用了gradient clipping 基于验证集损失的early stopping 实验结果]]></content>
      <categories>
        <category>Paper Notes</category>
        <category>Summarization</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Summarization</tag>
        <tag>Papers Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode 136] Single Number]]></title>
    <url>%2F2018%2F11%2F05%2F%5BLeetCode%20136%5D%20Single%20Number%2F</url>
    <content type="text"><![CDATA[给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 题目描述 English：Given an array of integers, every element appears twice except for one. Find that single one.Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 中文：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 思路异或（^）的几个性质： 顺序无关：多个元素异或的结果与元素的顺序无关。 同一个数异或两次等于没有异或：如4 ^ 3 ^ 4 = 3。 个数与0异或的结果为其本身：如3 ^ 0 = 3。 了解了这些性质，这道题就很简单了。result初始值设为0，将数组中每个元素都与result作异或并更新result，最终result的值就是那个唯一只出现一次的元素了。代码如下： class Solution { public: int singleNumber(vector&lt;int&gt; &amp;nums) { int result = 0; for (auto num:nums) { result ^= num; } return result; } };]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode 26 & 80] Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode-26-80-Remove-Duplicates-from-Sorted-Array%2F</url>
    <content type="text"><![CDATA[LeetCode 26题与80题，两者很相似，都是在有序数组中去除重复项。题目如下： 26. Remove Duplicates from Sorted Array（删除排序数组中的重复项） English：Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.中文：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 本题考察数组的基本操作。做法是维护两个指针，一个保留当前有效元素的长度，一个从前往后扫，然后跳过那些重复的元素。因为数组是有序的，所以重复元素一定相邻，不需要额外记录。时间复杂度是O(n)，空间复杂度O(1)。代码如下： class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 1) return nums.size(); int index = 1; for (int i = 1; i &lt; nums.size(); i++){ if (nums[i] != nums[index - 1]) nums[index++] = nums[i]; } return index; } }; 80. Remove Duplicates from Sorted Array II（删除排序数组中的重复项 II） English：Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.中文：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 和26题很相似，唯一的区别是允许每个元素最多出现两次，思路和26题是相同的，只需要将其中的1改为2即可。类似的，如果有其他的题目要求“允许每个元素最多出现n次”，将1改为n即可。代码如下： class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 2) return nums.size(); int index = 2; for (int i = 2; i &lt; nums.size(); i++){ if (nums[i] != nums[index - 2]) nums[index++] = nums[i]; } return index; } };]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100 numpy exercises]]></title>
    <url>%2F2018%2F09%2F28%2F100-numpy-exercises%2F</url>
    <content type="text"><![CDATA[100道关于numpy的练习 声明：并非原创，转自https://github.com/rougier/numpy-100 This is a collection of exercises that have been collected in the numpy mailing list, on stack overflow and in the numpy documentation. The goal of this collection is to offer a quick reference for both old and new users but also to provide a set of exercices for those who teach. If you find an error or think you’ve a better way to solve some of them, feel free to open an issue at https://github.com/rougier/numpy-100 1. Import the numpy package under the name np (★☆☆)1import numpy as np 2. Print the numpy version and the configuration (★☆☆)12print(np.__version__)np.show_config() 3. Create a null vector of size 10 (★☆☆)12Z = np.zeros(10)print(Z) 4. How to find the memory size of any array (★☆☆)12Z = np.zeros((10,10))print("%d bytes" % (Z.size * Z.itemsize)) 5. How to get the documentation of the numpy add function from the command line? (★☆☆)1%run `python -c "import numpy; numpy.info(numpy.add)"` 6. Create a null vector of size 10 but the fifth value which is 1 (★☆☆)123Z = np.zeros(10)Z[4] = 1print(Z) 7. Create a vector with values ranging from 10 to 49 (★☆☆)12Z = np.arange(10,50)print(Z) 8. Reverse a vector (first element becomes last) (★☆☆)123Z = np.arange(50)Z = Z[::-1]print(Z) 9. Create a 3x3 matrix with values ranging from 0 to 8 (★☆☆)12Z = np.arange(9).reshape(3,3)print(Z) 10. Find indices of non-zero elements from [1,2,0,0,4,0] (★☆☆)12nz = np.nonzero([1,2,0,0,4,0])print(nz) 11. Create a 3x3 identity matrix (★☆☆)12Z = np.eye(3)print(Z) 12. Create a 3x3x3 array with random values (★☆☆)12Z = np.random.random((3,3,3))print(Z) 13. Create a 10x10 array with random values and find the minimum and maximum values (★☆☆)123Z = np.random.random((10,10))Zmin, Zmax = Z.min(), Z.max()print(Zmin, Zmax) 14. Create a random vector of size 30 and find the mean value (★☆☆)123Z = np.random.random(30)m = Z.mean()print(m) 15. Create a 2d array with 1 on the border and 0 inside (★☆☆)123Z = np.ones((10,10))Z[1:-1,1:-1] = 0print(Z) 16. How to add a border (filled with 0’s) around an existing array? (★☆☆)123Z = np.ones((5,5))Z = np.pad(Z, pad_width=1, mode='constant', constant_values=0)print(Z) 17. What is the result of the following expression? (★☆☆)12345print(0 * np.nan)print(np.nan == np.nan)print(np.inf &gt; np.nan)print(np.nan - np.nan)print(0.3 == 3 * 0.1) 18. Create a 5x5 matrix with values 1,2,3,4 just below the diagonal (★☆☆)12Z = np.diag(1+np.arange(4),k=-1)print(Z) 19. Create a 8x8 matrix and fill it with a checkerboard pattern (★☆☆)1234Z = np.zeros((8,8),dtype=int)Z[1::2,::2] = 1Z[::2,1::2] = 1print(Z) 20. Consider a (6,7,8) shape array, what is the index (x,y,z) of the 100th element?1print(np.unravel_index(100,(6,7,8))) 21. Create a checkerboard 8x8 matrix using the tile function (★☆☆)12Z = np.tile( np.array([[0,1],[1,0]]), (4,4))print(Z) 22. Normalize a 5x5 random matrix (★☆☆)1234Z = np.random.random((5,5))Zmax, Zmin = Z.max(), Z.min()Z = (Z - Zmin)/(Zmax - Zmin)print(Z) 23. Create a custom dtype that describes a color as four unsigned bytes (RGBA) (★☆☆)1234color = np.dtype([("r", np.ubyte, 1), ("g", np.ubyte, 1), ("b", np.ubyte, 1), ("a", np.ubyte, 1)]) 24. Multiply a 5x3 matrix by a 3x2 matrix (real matrix product) (★☆☆)123456Z = np.dot(np.ones((5,3)), np.ones((3,2)))print(Z)# Alternative solution, in Python 3.5 and aboveZ = np.ones((5,3)) @ np.ones((3,2))print(Z) 25. Given a 1D array, negate all elements which are between 3 and 8, in place. (★☆☆)12345# Author: Evgeni BurovskiZ = np.arange(11)Z[(3 &lt; Z) &amp; (Z &lt;= 8)] *= -1print(Z) 26. What is the output of the following script? (★☆☆)12345# Author: Jake VanderPlasprint(sum(range(5),-1))from numpy import *print(sum(range(5),-1)) 27. Consider an integer vector Z, which of these expressions are legal? (★☆☆)123456Z**Z2 &lt;&lt; Z &gt;&gt; 2Z &lt;- Z1j*ZZ/1/1Z&lt;Z&gt;Z 28. What are the result of the following expressions?123print(np.array(0) / np.array(0))print(np.array(0) // np.array(0))print(np.array([np.nan]).astype(int).astype(float)) 29. How to round away from zero a float array ? (★☆☆)1234# Author: Charles R HarrisZ = np.random.uniform(-10,+10,10)print (np.copysign(np.ceil(np.abs(Z)), Z)) 30. How to find common values between two arrays? (★☆☆)123Z1 = np.random.randint(0,10,10)Z2 = np.random.randint(0,10,10)print(np.intersect1d(Z1,Z2)) 31. How to ignore all numpy warnings (not recommended)? (★☆☆)123456# Suicide mode ondefaults = np.seterr(all="ignore")Z = np.ones(1) / 0# Back to sanity_ = np.seterr(**defaults) An equivalent way, with a context manager: 12with np.errstate(divide='ignore'): Z = np.ones(1) / 0 32. Is the following expressions true? (★☆☆)1np.sqrt(-1) == np.emath.sqrt(-1) 33. How to get the dates of yesterday, today and tomorrow? (★☆☆)123yesterday = np.datetime64('today', 'D') - np.timedelta64(1, 'D')today = np.datetime64('today', 'D')tomorrow = np.datetime64('today', 'D') + np.timedelta64(1, 'D') 34. How to get all the dates corresponding to the month of July 2016? (★★☆)12Z = np.arange('2016-07', '2016-08', dtype='datetime64[D]')print(Z) 35. How to compute ((A+B)*(-A/2)) in place (without copy)? (★★☆)1234567A = np.ones(3)*1B = np.ones(3)*2C = np.ones(3)*3np.add(A,B,out=B)np.divide(A,2,out=A)np.negative(A,out=A)np.multiply(A,B,out=A) 36. Extract the integer part of a random array using 5 different methods (★★☆)1234567Z = np.random.uniform(0,10,10)print (Z - Z%1)print (np.floor(Z))print (np.ceil(Z)-1)print (Z.astype(int))print (np.trunc(Z)) 37. Create a 5x5 matrix with row values ranging from 0 to 4 (★★☆)123Z = np.zeros((5,5))Z += np.arange(5)print(Z) 38. Consider a generator function that generates 10 integers and use it to build an array (★☆☆)12345def generate(): for x in range(10): yield xZ = np.fromiter(generate(),dtype=float,count=-1)print(Z) 39. Create a vector of size 10 with values ranging from 0 to 1, both excluded (★★☆)12Z = np.linspace(0,1,11,endpoint=False)[1:]print(Z) 40. Create a random vector of size 10 and sort it (★★☆)123Z = np.random.random(10)Z.sort()print(Z) 41. How to sum a small array faster than np.sum? (★★☆)1234# Author: Evgeni BurovskiZ = np.arange(10)np.add.reduce(Z) 42. Consider two random array A and B, check if they are equal (★★☆)12345678910A = np.random.randint(0,2,5)B = np.random.randint(0,2,5)# Assuming identical shape of the arrays and a tolerance for the comparison of valuesequal = np.allclose(A,B)print(equal)# Checking both the shape and the element values, no tolerance (values have to be exactly equal)equal = np.array_equal(A,B)print(equal) 43. Make an array immutable (read-only) (★★☆)123Z = np.zeros(10)Z.flags.writeable = FalseZ[0] = 1 44. Consider a random 10x2 matrix representing cartesian coordinates, convert them to polar coordinates (★★☆)123456Z = np.random.random((10,2))X,Y = Z[:,0], Z[:,1]R = np.sqrt(X**2+Y**2)T = np.arctan2(Y,X)print(R)print(T) 45. Create random vector of size 10 and replace the maximum value by 0 (★★☆)123Z = np.random.random(10)Z[Z.argmax()] = 0print(Z) 46. Create a structured array with x and y coordinates covering the [0,1]x[0,1] area (★★☆)1234Z = np.zeros((5,5), [('x',float),('y',float)])Z['x'], Z['y'] = np.meshgrid(np.linspace(0,1,5), np.linspace(0,1,5))print(Z) 47. Given two arrays, X and Y, construct the Cauchy matrix C (Cij =1/(xi - yj))123456# Author: Evgeni BurovskiX = np.arange(8)Y = X + 0.5C = 1.0 / np.subtract.outer(X, Y)print(np.linalg.det(C)) 48. Print the minimum and maximum representable value for each numpy scalar type (★★☆)1234567for dtype in [np.int8, np.int32, np.int64]: print(np.iinfo(dtype).min) print(np.iinfo(dtype).max)for dtype in [np.float32, np.float64]: print(np.finfo(dtype).min) print(np.finfo(dtype).max) print(np.finfo(dtype).eps) 49. How to print all the values of an array? (★★☆)123np.set_printoptions(threshold=np.nan)Z = np.zeros((16,16))print(Z) 50. How to find the closest value (to a given scalar) in a vector? (★★☆)1234Z = np.arange(100)v = np.random.uniform(0,100)index = (np.abs(Z-v)).argmin()print(Z[index]) 51. Create a structured array representing a position (x,y) and a color (r,g,b) (★★☆)123456Z = np.zeros(10, [ ('position', [ ('x', float, 1), ('y', float, 1)]), ('color', [ ('r', float, 1), ('g', float, 1), ('b', float, 1)])])print(Z) 52. Consider a random vector with shape (100,2) representing coordinates, find point by point distances (★★☆)12345678910111213Z = np.random.random((10,2))X,Y = np.atleast_2d(Z[:,0], Z[:,1])D = np.sqrt( (X-X.T)**2 + (Y-Y.T)**2)print(D)# Much faster with scipyimport scipy# Thanks Gavin Heverly-Coulson (#issue 1)import scipy.spatialZ = np.random.random((10,2))D = scipy.spatial.distance.cdist(Z,Z)print(D) 53. How to convert a float (32 bits) array into an integer (32 bits) in place?123Z = np.arange(10, dtype=np.int32)Z = Z.astype(np.float32, copy=False)print(Z) 54. How to read the following file? (★★☆)12345678from io import StringIO# Fake file s = StringIO("""1, 2, 3, 4, 5\n 6, , , 7, 8\n , , 9,10,11\n""")Z = np.genfromtxt(s, delimiter=",", dtype=np.int)print(Z) 55. What is the equivalent of enumerate for numpy arrays? (★★☆)12345Z = np.arange(9).reshape(3,3)for index, value in np.ndenumerate(Z): print(index, value)for index in np.ndindex(Z.shape): print(index, Z[index]) 56. Generate a generic 2D Gaussian-like array (★★☆)12345X, Y = np.meshgrid(np.linspace(-1,1,10), np.linspace(-1,1,10))D = np.sqrt(X*X+Y*Y)sigma, mu = 1.0, 0.0G = np.exp(-( (D-mu)**2 / ( 2.0 * sigma**2 ) ) )print(G) 57. How to randomly place p elements in a 2D array? (★★☆)1234567# Author: Divakarn = 10p = 3Z = np.zeros((n,n))np.put(Z, np.random.choice(range(n*n), p, replace=False),1)print(Z) 58. Subtract the mean of each row of a matrix (★★☆)1234567891011# Author: Warren WeckesserX = np.random.rand(5, 10)# Recent versions of numpyY = X - X.mean(axis=1, keepdims=True)# Older versions of numpyY = X - X.mean(axis=1).reshape(-1, 1)print(Y) 59. How to I sort an array by the nth column? (★★☆)12345# Author: Steve TjoaZ = np.random.randint(0,10,(3,3))print(Z)print(Z[Z[:,1].argsort()]) 60. How to tell if a given 2D array has null columns? (★★☆)1234# Author: Warren WeckesserZ = np.random.randint(0,3,(3,10))print((~Z.any(axis=0)).any()) 61. Find the nearest value from a given value in an array (★★☆)1234Z = np.random.uniform(0,1,10)z = 0.5m = Z.flat[np.abs(Z - z).argmin()]print(m) 62. Considering two arrays with shape (1,3) and (3,1), how to compute their sum using an iterator? (★★☆)12345A = np.arange(3).reshape(3,1)B = np.arange(3).reshape(1,3)it = np.nditer([A,B,None])for x,y,z in it: z[...] = x + yprint(it.operands[2]) 63. Create an array class that has a name attribute (★★☆)1234567891011class NamedArray(np.ndarray): def __new__(cls, array, name="no name"): obj = np.asarray(array).view(cls) obj.name = name return obj def __array_finalize__(self, obj): if obj is None: return self.info = getattr(obj, 'name', "no name")Z = NamedArray(np.arange(10), "range_10")print (Z.name) 64. Consider a given vector, how to add 1 to each element indexed by a second vector (be careful with repeated indices)? (★★★)1234567891011# Author: Brett OlsenZ = np.ones(10)I = np.random.randint(0,len(Z),20)Z += np.bincount(I, minlength=len(Z))print(Z)# Another solution# Author: Bartosz Telenczuknp.add.at(Z, I, 1)print(Z) 65. How to accumulate elements of a vector (X) to an array (F) based on an index list (I)? (★★★)123456# Author: Alan G IsaacX = [1,2,3,4,5,6]I = [1,3,9,3,4,1]F = np.bincount(I,X)print(F) 66. Considering a (w,h,3) image of (dtype=ubyte), compute the number of unique colors (★★★)1234567# Author: Nadav Horeshw,h = 16,16I = np.random.randint(0,2,(h,w,3)).astype(np.ubyte)F = I[...,0]*256*256 + I[...,1]*256 +I[...,2]n = len(np.unique(F))print(np.unique(I)) 67. Considering a four dimensions array, how to get sum over the last two axis at once? (★★★)12345678A = np.random.randint(0,10,(3,4,3,4))# solution by passing a tuple of axes (introduced in numpy 1.7.0)sum = A.sum(axis=(-2,-1))print(sum)# solution by flattening the last two dimensions into one# (useful for functions that don't accept tuples for axis argument)sum = A.reshape(A.shape[:-2] + (-1,)).sum(axis=-1)print(sum) 68. Considering a one-dimensional vector D, how to compute means of subsets of D using a vector S of same size describing subset indices? (★★★)123456789101112# Author: Jaime Fernández del RíoD = np.random.uniform(0,1,100)S = np.random.randint(0,10,100)D_sums = np.bincount(S, weights=D)D_counts = np.bincount(S)D_means = D_sums / D_countsprint(D_means)# Pandas solution as a reference due to more intuitive codeimport pandas as pdprint(pd.Series(D).groupby(S).mean()) 69. How to get the diagonal of a dot product? (★★★)12345678910111213# Author: Mathieu BlondelA = np.random.uniform(0,1,(5,5))B = np.random.uniform(0,1,(5,5))# Slow version np.diag(np.dot(A, B))# Fast versionnp.sum(A * B.T, axis=1)# Faster versionnp.einsum("ij,ji-&gt;i", A, B) 70. Consider the vector [1, 2, 3, 4, 5], how to build a new vector with 3 consecutive zeros interleaved between each value? (★★★)1234567# Author: Warren WeckesserZ = np.array([1,2,3,4,5])nz = 3Z0 = np.zeros(len(Z) + (len(Z)-1)*(nz))Z0[::nz+1] = Zprint(Z0) 71. Consider an array of dimension (5,5,3), how to mulitply it by an array with dimensions (5,5)? (★★★)123A = np.ones((5,5,3))B = 2*np.ones((5,5))print(A * B[:,:,None]) 72. How to swap two rows of an array? (★★★)12345# Author: Eelco HoogendoornA = np.arange(25).reshape(5,5)A[[0,1]] = A[[1,0]]print(A) 73. Consider a set of 10 triplets describing 10 triangles (with shared vertices), find the set of unique line segments composing all the triangles (★★★)123456789# Author: Nicolas P. Rougierfaces = np.random.randint(0,100,(10,3))F = np.roll(faces.repeat(2,axis=1),-1,axis=1)F = F.reshape(len(F)*3,2)F = np.sort(F,axis=1)G = F.view( dtype=[('p0',F.dtype),('p1',F.dtype)] )G = np.unique(G)print(G) 74. Given an array C that is a bincount, how to produce an array A such that np.bincount(A) == C? (★★★)12345# Author: Jaime Fernández del RíoC = np.bincount([1,1,2,3,4,4,6])A = np.repeat(np.arange(len(C)), C)print(A) 75. How to compute averages using a sliding window over an array? (★★★)12345678# Author: Jaime Fernández del Ríodef moving_average(a, n=3) : ret = np.cumsum(a, dtype=float) ret[n:] = ret[n:] - ret[:-n] return ret[n - 1:] / nZ = np.arange(20)print(moving_average(Z, n=3)) 76. Consider a one-dimensional array Z, build a two-dimensional array whose first row is (Z[0],Z[1],Z[2]) and each subsequent row is shifted by 1 (last row should be (Z[-3],Z[-2],Z[-1]) (★★★)123456789# Author: Joe Kington / Erik Rigtorpfrom numpy.lib import stride_tricksdef rolling(a, window): shape = (a.size - window + 1, window) strides = (a.itemsize, a.itemsize) return stride_tricks.as_strided(a, shape=shape, strides=strides)Z = rolling(np.arange(10), 3)print(Z) 77. How to negate a boolean, or to change the sign of a float inplace? (★★★)1234567# Author: Nathaniel J. SmithZ = np.random.randint(0,2,100)np.logical_not(Z, out=Z)Z = np.random.uniform(-1.0,1.0,100)np.negative(Z, out=Z) 78. Consider 2 sets of points P0,P1 describing lines (2d) and a point p, how to compute distance from p to each line i (P0[i],P1[i])? (★★★)123456789101112def distance(P0, P1, p): T = P1 - P0 L = (T**2).sum(axis=1) U = -((P0[:,0]-p[...,0])*T[:,0] + (P0[:,1]-p[...,1])*T[:,1]) / L U = U.reshape(len(U),1) D = P0 + U*T - p return np.sqrt((D**2).sum(axis=1))P0 = np.random.uniform(-10,10,(10,2))P1 = np.random.uniform(-10,10,(10,2))p = np.random.uniform(-10,10,( 1,2))print(distance(P0, P1, p)) 79. Consider 2 sets of points P0,P1 describing lines (2d) and a set of points P, how to compute distance from each point j (P[j]) to each line i (P0[i],P1[i])? (★★★)1234567# Author: Italmassov Kuanysh# based on distance function from previous questionP0 = np.random.uniform(-10, 10, (10,2))P1 = np.random.uniform(-10,10,(10,2))p = np.random.uniform(-10, 10, (10,2))print(np.array([distance(P0,P1,p_i) for p_i in p])) 80. Consider an arbitrary array, write a function that extract a subpart with a fixed shape and centered on a given element (pad with a fill value when necessary) (★★★)123456789101112131415161718192021222324252627# Author: Nicolas RougierZ = np.random.randint(0,10,(10,10))shape = (5,5)fill = 0position = (1,1)R = np.ones(shape, dtype=Z.dtype)*fillP = np.array(list(position)).astype(int)Rs = np.array(list(R.shape)).astype(int)Zs = np.array(list(Z.shape)).astype(int)R_start = np.zeros((len(shape),)).astype(int)R_stop = np.array(list(shape)).astype(int)Z_start = (P-Rs//2)Z_stop = (P+Rs//2)+Rs%2R_start = (R_start - np.minimum(Z_start,0)).tolist()Z_start = (np.maximum(Z_start,0)).tolist()R_stop = np.maximum(R_start, (R_stop - np.maximum(Z_stop-Zs,0))).tolist()Z_stop = (np.minimum(Z_stop,Zs)).tolist()r = [slice(start,stop) for start,stop in zip(R_start,R_stop)]z = [slice(start,stop) for start,stop in zip(Z_start,Z_stop)]R[r] = Z[z]print(Z)print(R) 81. Consider an array Z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14], how to generate an array R = [[1,2,3,4], [2,3,4,5], [3,4,5,6], …, [11,12,13,14]]? (★★★)12345# Author: Stefan van der WaltZ = np.arange(1,15,dtype=np.uint32)R = stride_tricks.as_strided(Z,(11,4),(4,4))print(R) 82. Compute a matrix rank (★★★)123456# Author: Stefan van der WaltZ = np.random.uniform(0,1,(10,10))U, S, V = np.linalg.svd(Z) # Singular Value Decompositionrank = np.sum(S &gt; 1e-10)print(rank) 83. How to find the most frequent value in an array?12Z = np.random.randint(0,10,50)print(np.bincount(Z).argmax()) 84. Extract all the contiguous 3x3 blocks from a random 10x10 matrix (★★★)12345678# Author: Chris BarkerZ = np.random.randint(0,5,(10,10))n = 3i = 1 + (Z.shape[0]-3)j = 1 + (Z.shape[1]-3)C = stride_tricks.as_strided(Z, shape=(i, j, n, n), strides=Z.strides + Z.strides)print(C) 85. Create a 2D array subclass such that Z[i,j] == Z[j,i] (★★★)123456789101112131415# Author: Eric O. Lebigot# Note: only works for 2d array and value setting using indicesclass Symetric(np.ndarray): def __setitem__(self, index, value): i,j = index super(Symetric, self).__setitem__((i,j), value) super(Symetric, self).__setitem__((j,i), value)def symetric(Z): return np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric)S = symetric(np.random.randint(0,10,(5,5)))S[2,3] = 42print(S) 86. Consider a set of p matrices wich shape (n,n) and a set of p vectors with shape (n,1). How to compute the sum of of the p matrix products at once? (result has shape (n,1)) (★★★)12345678910111213# Author: Stefan van der Waltp, n = 10, 20M = np.ones((p,n,n))V = np.ones((p,n,1))S = np.tensordot(M, V, axes=[[0, 2], [0, 1]])print(S)# It works, because:# M is (p,n,n)# V is (p,n,1)# Thus, summing over the paired axes 0 and 0 (of M and V independently),# and 2 and 1, to remain with a (n,1) vector. 87. Consider a 16x16 array, how to get the block-sum (block size is 4x4)? (★★★)1234567# Author: Robert KernZ = np.ones((16,16))k = 4S = np.add.reduceat(np.add.reduceat(Z, np.arange(0, Z.shape[0], k), axis=0), np.arange(0, Z.shape[1], k), axis=1)print(S) 88. How to implement the Game of Life using numpy arrays? (★★★)123456789101112131415161718# Author: Nicolas Rougierdef iterate(Z): # Count neighbours N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] + Z[1:-1,0:-2] + Z[1:-1,2:] + Z[2: ,0:-2] + Z[2: ,1:-1] + Z[2: ,2:]) # Apply rules birth = (N==3) &amp; (Z[1:-1,1:-1]==0) survive = ((N==2) | (N==3)) &amp; (Z[1:-1,1:-1]==1) Z[...] = 0 Z[1:-1,1:-1][birth | survive] = 1 return ZZ = np.random.randint(0,2,(50,50))for i in range(100): Z = iterate(Z)print(Z) 89. How to get the n largest values of an array (★★★)123456789Z = np.arange(10000)np.random.shuffle(Z)n = 5# Slowprint (Z[np.argsort(Z)[-n:]])# Fastprint (Z[np.argpartition(-Z,n)[:n]]) 90. Given an arbitrary number of vectors, build the cartesian product (every combinations of every item) (★★★)123456789101112131415# Author: Stefan Van der Waltdef cartesian(arrays): arrays = [np.asarray(a) for a in arrays] shape = (len(x) for x in arrays) ix = np.indices(shape, dtype=int) ix = ix.reshape(len(arrays), -1).T for n, arr in enumerate(arrays): ix[:, n] = arrays[n][ix[:, n]] return ixprint (cartesian(([1, 2, 3], [4, 5], [6, 7]))) 91. How to create a record array from a regular array? (★★★)123456Z = np.array([("Hello", 2.5, 3), ("World", 3.6, 2)])R = np.core.records.fromarrays(Z.T, names='col1, col2, col3', formats = 'S8, f8, i8')print(R) 92. Consider a large vector Z, compute Z to the power of 3 using 3 different methods (★★★)1234567# Author: Ryan G.x = np.random.rand(5e7)%timeit np.power(x,3)%timeit x*x*x%timeit np.einsum('i,i,i-&gt;i',x,x,x) 93. Consider two arrays A and B of shape (8,3) and (2,2). How to find rows of A that contain elements of each row of B regardless of the order of the elements in B? (★★★)12345678# Author: Gabe SchwartzA = np.random.randint(0,5,(8,3))B = np.random.randint(0,5,(2,2))C = (A[..., np.newaxis, np.newaxis] == B)rows = np.where(C.any((3,1)).all(1))[0]print(rows) 94. Considering a 10x3 matrix, extract rows with unequal values (e.g. [2,2,3]) (★★★)1234567891011# Author: Robert KernZ = np.random.randint(0,5,(10,3))print(Z)# solution for arrays of all dtypes (including string arrays and record arrays)E = np.all(Z[:,1:] == Z[:,:-1], axis=1)U = Z[~E]print(U)# soluiton for numerical arrays only, will work for any number of columns in ZU = Z[Z.max(axis=1) != Z.min(axis=1),:]print(U) 95. Convert a vector of ints into a matrix binary representation (★★★)12345678910# Author: Warren WeckesserI = np.array([0, 1, 2, 3, 15, 16, 32, 64, 128])B = ((I.reshape(-1,1) &amp; (2**np.arange(8))) != 0).astype(int)print(B[:,::-1])# Author: Daniel T. McDonaldI = np.array([0, 1, 2, 3, 15, 16, 32, 64, 128], dtype=np.uint8)print(np.unpackbits(I[:, np.newaxis], axis=1)) 96. Given a two dimensional array, how to extract unique rows? (★★★)1234567# Author: Jaime Fernández del RíoZ = np.random.randint(0,2,(6,3))T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[1])))_, idx = np.unique(T, return_index=True)uZ = Z[idx]print(uZ) 97. Considering 2 vectors A &amp; B, write the einsum equivalent of inner, outer, sum, and mul function (★★★)12345678910# Author: Alex Riley# Make sure to read: http://ajcr.net/Basic-guide-to-einsum/A = np.random.uniform(0,1,10)B = np.random.uniform(0,1,10)np.einsum('i-&gt;', A) # np.sum(A)np.einsum('i,i-&gt;i', A, B) # A * Bnp.einsum('i,i', A, B) # np.inner(A, B)np.einsum('i,j-&gt;ij', A, B) # np.outer(A, B) 98. Considering a path described by two vectors (X,Y), how to sample it using equidistant samples (★★★)?12345678910111213# Author: Bas Swinckelsphi = np.arange(0, 10*np.pi, 0.1)a = 1x = a*phi*np.cos(phi)y = a*phi*np.sin(phi)dr = (np.diff(x)**2 + np.diff(y)**2)**.5 # segment lengthsr = np.zeros_like(x)r[1:] = np.cumsum(dr) # integrate pathr_int = np.linspace(0, r.max(), 200) # regular spaced pathx_int = np.interp(r_int, r, x) # integrate pathy_int = np.interp(r_int, r, y) 99. Given an integer n and a 2D array X, select from X the rows which can be interpreted as draws from a multinomial distribution with n degrees, i.e., the rows which only contain integers and which sum to n. (★★★)123456789# Author: Evgeni BurovskiX = np.asarray([[1.0, 0.0, 3.0, 8.0], [2.0, 0.0, 1.0, 1.0], [1.5, 2.5, 1.0, 0.0]])n = 4M = np.logical_and.reduce(np.mod(X, 1) == 0, axis=-1)M &amp;= (X.sum(axis=-1) == n)print(X[M]) 100. Compute bootstrapped 95% confidence intervals for the mean of a 1D array X (i.e., resample the elements of an array with replacement N times, compute the mean of each sample, and then compute percentiles over the means). (★★★)12345678# Author: Jessica B. HamrickX = np.random.randn(100) # random 1D arrayN = 1000 # number of bootstrap samplesidx = np.random.randint(0, X.size, (N, X.size))means = X[idx].mean(axis=1)confint = np.percentile(means, [2.5, 97.5])print(confint)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
</search>
